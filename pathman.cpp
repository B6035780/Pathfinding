#include <unordered_map>
#include <queue>
#include <vector>
#include <cassert>
constexpr int32_t maze_width		= 224;
constexpr int32_t maze_height		= 248;
constexpr int32_t tile_map_width	= maze_width / 8;
constexpr int32_t tile_map_height	= maze_height / 8;
constexpr int32_t display_scale		= 4;
constexpr int32_t display_width		= maze_width * display_scale;
constexpr int32_t display_height	= maze_height * display_scale;

enum tile_flags : uint8_t
{
	tile_flags_wall			= 0x00,
	tile_flags_open_up		= 0x01,
	tile_flags_open_down	= 0x02,
	tile_flags_open_left	= 0x04,
	tile_flags_open_right	= 0x08,
};

// 0x0 == wall, 0xA == S&E, 0xC == E&W, 0xE == S&E&W, 0x6 == W&S, 0xD == N&E&W, 0xB == N&E&S, 0xF == ALL, 0x5 == W&N, 0x7 == N&S&W, 0x9 == N&E
static uint8_t tile_map[tile_map_width * tile_map_height] = {
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0xA,0xC,0xC,0xC,0xC,0xE,0xC,0xC,0xC,0xC,0xC,0x6,0x0,0x0,0xA,0xC,0xC,0xC,0xC,0xC,0xE,0xC,0xC,0xC,0xC,0x6,0x0,
	0x0,0x3,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x3,0x0,
	0x0,0x3,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x3,0x0,
	0x0,0x3,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x3,0x0,
	0x0,0xB,0xC,0xC,0xC,0xC,0xF,0xC,0xC,0xE,0xC,0xC,0xD,0xC,0xC,0xD,0xC,0xC,0xE,0xC,0xC,0xF,0xC,0xC,0xC,0xC,0x7,0x0,
	0x0,0x3,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x3,0x0,
	0x0,0x3,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x3,0x0,
	0x0,0x9,0xC,0xC,0xC,0xC,0x7,0x0,0x0,0x9,0xC,0xC,0x6,0x0,0x0,0xA,0xC,0xC,0x5,0x0,0x0,0xB,0xC,0xC,0xC,0xC,0x5,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0xA,0xC,0xC,0xD,0xC,0xC,0xD,0xC,0xC,0x6,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0xB,0xC,0xC,0x6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xB,0xC,0xC,0x6,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0xB,0xC,0xC,0xC,0xC,0xC,0xC,0xC,0xC,0x6,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0xA,0xC,0xC,0xC,0xC,0xF,0xC,0xC,0xD,0xC,0xC,0x6,0x0,0x0,0xA,0xC,0xC,0xB,0xC,0xC,0xF,0xC,0xC,0xC,0xC,0x6,0x0,
	0x0,0x3,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x3,0x0,
	0x0,0x3,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x3,0x0,
	0x0,0x9,0xC,0x6,0x0,0x0,0xB,0xC,0xC,0xE,0xC,0xC,0xD,0xC,0xC,0xD,0xC,0xC,0xE,0xC,0xC,0x7,0x0,0x0,0xA,0xC,0x5,0x0,
	0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,
	0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,
	0x0,0xA,0xC,0xD,0xC,0xC,0x5,0x0,0x0,0x9,0xC,0xC,0x6,0x0,0x0,0xA,0xC,0xC,0x5,0x0,0x0,0x9,0xC,0xC,0xD,0xC,0xA,0x0,
	0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,
	0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,
	0x0,0x9,0xC,0xC,0xC,0xC,0xC,0xC,0xC,0xC,0xC,0xC,0xD,0xC,0xC,0xD,0xC,0xC,0xC,0xC,0xC,0xC,0xC,0xC,0xC,0xC,0x5,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
};

static uint32_t	pathman_anim_counter;
static uint32_t	ghost_anim_counter;
static int32_t	pathman_tile_x	= 1;
static int32_t	pathman_tile_y	= 1;
static int32_t	ghost_tile_x	= 13;
static int32_t	ghost_tile_y	= 17;

template<typename T, typename priority_t>
struct PriorityQueue
{
	typedef std::pair<priority_t, T> PQElement;
	std::priority_queue<PQElement, std::vector<PQElement>, std::greater<PQElement>> elements;

	inline bool empty() const
	{
		return elements.empty();
	}

	inline void put(T item, priority_t priority)
	{
		elements.emplace(priority, item);
	}

	T get()
	{
		T best_item = elements.top().second;
		elements.pop();
		return best_item;
	}
};

struct Location
{
	Location() : x(0), y(0) {};
	Location(int x, int y) : x(x), y(y) {};
	int x, y;

	bool operator==(const Location& rh) const
	{
		return x == rh.x && y == rh.y;
	}

	bool operator<(const Location& rh) const
	{
		return std::tie(x, y) < std::tie(rh.x, rh.y);
	}
};

namespace std {
	/* implement hash function so we can put GridLocation into an unordered_set */
	template <> struct hash<Location> {
		typedef Location argument_type;
		typedef std::size_t result_type;
		std::size_t operator()(const Location& id) const noexcept {
			return std::hash<int>()(id.x ^ (id.y << 4));
		}
	};
}


std::vector<Location> neighbours(Location id) 
{
	std::vector<Location> results;
	std::vector<Location> DIRS;

	Location N(0, -1);
	Location E(1, 0);
	Location S(0, 1);
	Location W(-1, 0);

	switch (tile_map[id.x + (id.y * tile_map_width)])	//Checks which directions pathman can move based on the flag in tilemap
	{
	case 10:
		DIRS.push_back(S);
		DIRS.push_back(E);
		break;
	case 11:
		DIRS.push_back(S);
		DIRS.push_back(N);
		DIRS.push_back(E);
		break;
	case 12:
		DIRS.push_back(E);
		DIRS.push_back(W);
		break;
	case 13:
		DIRS.push_back(N);
		DIRS.push_back(E);
		DIRS.push_back(W);
		break;
	case 14:
		DIRS.push_back(S);
		DIRS.push_back(E);
		DIRS.push_back(W);
		break;
	case 15:
		DIRS.push_back(N);
		DIRS.push_back(E);
		DIRS.push_back(S);
		DIRS.push_back(W);
		break;
	case 3:
		DIRS.push_back(S);
		DIRS.push_back(N);
		break;
	case 5:
		DIRS.push_back(N);
		DIRS.push_back(W);
		break;
	case 6:
		DIRS.push_back(S);
		DIRS.push_back(W);
		break;
	case 7:
		DIRS.push_back(N);
		DIRS.push_back(S);
		DIRS.push_back(W);
		break;
	case 9:
		DIRS.push_back(N);
		DIRS.push_back(E);
		break;
	default:
		assert(false);
		break;
	}

	for (Location dir : DIRS)
	{
		Location next(id.x + dir.x, id.y + dir.y);
		results.push_back(next);
	}

	if ((id.x + id.y) % 2 == 0) {
		//aesthetic improvement on square grids
		std::reverse(results.begin(), results.end());
	}

	return results;
}

double heuristic(Location next, Location goal)	//for a* search
{
	return std::abs(next.x - goal.x) + std::abs(next.y - goal.y);
}

double cost(Location current, Location next)	//We don't have different terrain types, and walls can't be moved to, so cost is always 0
{
	return 0.0;
}

void breadthFirstSearch(Location start, Location goal, std::unordered_map<Location, Location>& cameFrom)
{
	std::queue<Location> frontier;
	frontier.push(start);

	cameFrom[start] = start;

	while (!frontier.empty()) 
	{
		Location current = frontier.front();
		frontier.pop();

		if (current == goal) 
			break;
		

		for (Location next : neighbours(current)) 
		{
			if (cameFrom.find(next) == cameFrom.end())
			{
				frontier.push(next);
				cameFrom[next] = current;
			}
		}
	}
}

void aStarSearch(Location start, Location goal, std::unordered_map<Location, Location>& cameFrom,
	std::unordered_map<Location, double>& costSoFar)
{
	//std::priority_queue<Location, double, std::greater<double>> frontier;
	PriorityQueue<Location, double> frontier;
	frontier.put(start, 0.0);

	cameFrom[start] = start;
	costSoFar[start] = 0.0;

	while (!frontier.empty())
	{
		Location current = frontier.get();

		if (current == goal)
			break;

		for (Location next : neighbours(current))
		{
			double newCost = costSoFar[current] + cost(current, next);
			
			if (costSoFar.find(next) == costSoFar.end()
				|| newCost < costSoFar[next])
			{
				costSoFar[next] = newCost;
				double prio = newCost + heuristic(next, goal);
				frontier.put(next, prio);
				cameFrom[next] = current;
			}
		}
	}
}

static void draw_sprite(sprite_batch* sb, texture* sprite_sheet, int32_t tile_x, int32_t tile_y, int32_t src_x, int32_t src_y)
{
	const int32_t x = (tile_x * 8) - 3;
	const int32_t y = (tile_y * 8) - 3;

	sprite_batch_draw(sb, sprite_sheet, x * display_scale, y * display_scale, 14 * display_scale, 14 * display_scale, src_x, src_y, 14, 14);
}

static void render(d3d_context* d3d, sprite_batch* sb, texture* sprite_sheet, std::unordered_map<Location, Location>& came_from)
{
	sprite_batch_begin(sb);

	sprite_batch_draw(sb, sprite_sheet, 0, 0, 224 * display_scale, 248 * display_scale, 228, 0, 224, 248);

	if (ghost_anim_counter < 8)
		draw_sprite(sb, sprite_sheet, ghost_tile_x, ghost_tile_y, 585, 65);
	else
		draw_sprite(sb, sprite_sheet, ghost_tile_x, ghost_tile_y, 601, 65);
	bool path = true;

	Location last(ghost_tile_x, ghost_tile_y), Start(pathman_tile_x, pathman_tile_y);
	while (path)	//Draws a ghost sprite along the path calculated for pathman
	{
		if (came_from[last] == Start)
			path = false;
		else
		{
			draw_sprite(sb, sprite_sheet, came_from[last].x, came_from[last].y, 601, 65);
			last = came_from[last];
		}
	}

	if (++ghost_anim_counter == 16)
		ghost_anim_counter = 0;

	if (pathman_anim_counter < 8)
		draw_sprite(sb, sprite_sheet, pathman_tile_x, pathman_tile_y, 457, 1);
	else if (pathman_anim_counter < 16)
		draw_sprite(sb, sprite_sheet, pathman_tile_x, pathman_tile_y, 473, 1);
	else
		draw_sprite(sb, sprite_sheet, pathman_tile_x, pathman_tile_y, 489, 1);

	if (++pathman_anim_counter == 24)
		pathman_anim_counter = 0;

	sprite_batch_end(sb);
}

static void load_sprite_sheet(texture* sprite_sheet, d3d_context* d3d)
{
	size_t image_file_size;
	void* image_file_data = read_entire_file("asset/pacman.png", &image_file_size);
	load_png(d3d, sprite_sheet, image_file_data, image_file_size);
	free(image_file_data);
}

int main(void)
{
	// Create and open window
	display_context display;
	create_display(&display, "Path-Man", -1, -1, display_width, display_height, false);

	// Initialise D3D
	d3d_context d3d;
	init_d3d(&d3d, &display, true);

	// Initialise sprite batch renderer
	sprite_batch sb;
	sprite_batch_init(&sb, &d3d);

	// Load assets
	texture sprite_sheet;
	load_sprite_sheet(&sprite_sheet, &d3d);

	Location start{ pathman_tile_x, pathman_tile_y };
	Location goal{ ghost_tile_x, ghost_tile_y };

	std::unordered_map<Location, Location> came_from;
	std::unordered_map<Location, double> cost_so_far;
	aStarSearch(start, goal, came_from, cost_so_far);
	breadthFirstSearch(start, goal, came_from);

	// Main loop
	bool quit = false;
	while (!quit)
	{
		// Handle all queued messages from Windows API
		MSG msg;
		while (PeekMessageW(&msg, nullptr, 0, 0, PM_REMOVE))
		{
			switch (msg.message)
			{
			case WM_QUIT:
				quit = true;
				break;
			default:
				TranslateMessage(&msg);
				DispatchMessage(&msg);
			}
		}

		begin_frame(&d3d);

		// Rendering code goes here
		render(&d3d, &sb, &sprite_sheet, came_from);

		end_frame(&d3d);
	}

	// Release D3D objects in order to shut down cleanly
	sprite_sheet.buffer->Release();
	sprite_sheet.srv->Release();
	sprite_batch_term(&sb);
	term_d3d(&d3d);

	// Tell windows to terminate the application process and return a successful error code
	ExitProcess(0);
}